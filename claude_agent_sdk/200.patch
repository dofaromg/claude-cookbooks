From 9484a51f4e68901e385bed402059088cc935b41c Mon Sep 17 00:00:00 2001
From: "Mr.liou" <z814241@gmail.com>
Date: Sat, 3 Jan 2026 08:40:18 +0800
Subject: [PATCH] Add FlowOS TypeScript skeleton

---
 .gitignore                            |   1 +
 flowos/package.json                   |  13 ++
 flowos/src/app/artifacts/index.ts     |  38 ++++++
 flowos/src/app/conversations/index.ts |  40 +++++++
 flowos/src/app/memory/index.ts        |  22 ++++
 flowos/src/app/projects/index.ts      |  21 ++++
 flowos/src/app/tools/index.ts         |  24 ++++
 flowos/src/core/chains/index.ts       |  43 +++++++
 flowos/src/core/particles/index.ts    |  26 ++++
 flowos/src/core/particles/store.ts    |  81 +++++++++++++
 flowos/src/core/personas/index.ts     |  31 +++++
 flowos/src/core/seeds/index.ts        |  31 +++++
 flowos/src/index.ts                   |  73 ++++++++++++
 flowos/src/lib/flow-law.ts            |  27 +++++
 flowos/src/storage/index.ts           | 101 ++++++++++++++++
 flowos/src/types/index.ts             | 163 ++++++++++++++++++++++++++
 flowos/src/utils/index.ts             |  32 +++++
 flowos/test.ts                        |  20 ++++
 flowos/tsconfig.json                  |  16 +++
 package-lock.json                     |  35 ++++++
 package.json                          |  12 +-
 21 files changed, 846 insertions(+), 4 deletions(-)
 create mode 100644 flowos/package.json
 create mode 100644 flowos/src/app/artifacts/index.ts
 create mode 100644 flowos/src/app/conversations/index.ts
 create mode 100644 flowos/src/app/memory/index.ts
 create mode 100644 flowos/src/app/projects/index.ts
 create mode 100644 flowos/src/app/tools/index.ts
 create mode 100644 flowos/src/core/chains/index.ts
 create mode 100644 flowos/src/core/particles/index.ts
 create mode 100644 flowos/src/core/particles/store.ts
 create mode 100644 flowos/src/core/personas/index.ts
 create mode 100644 flowos/src/core/seeds/index.ts
 create mode 100644 flowos/src/index.ts
 create mode 100644 flowos/src/lib/flow-law.ts
 create mode 100644 flowos/src/storage/index.ts
 create mode 100644 flowos/src/types/index.ts
 create mode 100644 flowos/src/utils/index.ts
 create mode 100644 flowos/test.ts
 create mode 100644 flowos/tsconfig.json

diff --git a/.gitignore b/.gitignore
index e969bb6..7ff714b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -247,3 +247,4 @@ particle_core/backups/
 /data/notion_export.json
 /data/github_export.json
 /data/snapshots/*.json
+flowos/dist/
diff --git a/flowos/package.json b/flowos/package.json
new file mode 100644
index 0000000..0e107aa
--- /dev/null
+++ b/flowos/package.json
@@ -0,0 +1,13 @@
+{
+  "name": "flowos",
+  "version": "0.1.0",
+  "private": true,
+  "description": "Lightweight FlowOS runtime skeleton with core FlowAgent building blocks.",
+  "main": "dist/index.js",
+  "types": "dist/index.d.ts",
+  "scripts": {
+    "build": "tsc -p tsconfig.json",
+    "test": "node --experimental-modules --no-warnings dist/test.js",
+    "typecheck": "tsc -p tsconfig.json --noEmit"
+  }
+}
diff --git a/flowos/src/app/artifacts/index.ts b/flowos/src/app/artifacts/index.ts
new file mode 100644
index 0000000..9f96c22
--- /dev/null
+++ b/flowos/src/app/artifacts/index.ts
@@ -0,0 +1,38 @@
+import { ArtifactRecord, ArtifactVersion } from '../../types';
+import { MemoryStorage } from '../../storage';
+import { now, randomId } from '../../utils';
+
+export class ArtifactVault {
+  constructor(private readonly storage: MemoryStorage) {}
+
+  registerArtifact(project: string, name: string, description?: string): ArtifactRecord {
+    const record: ArtifactRecord = {
+      id: randomId(),
+      project,
+      name,
+      description,
+      versions: [],
+    };
+    return this.storage.upsertArtifact(record);
+  }
+
+  addVersion(artifactId: string, version: string, metadata?: Record<string, unknown>): ArtifactRecord {
+    const existing = this.storage.listArtifacts().find((artifact) => artifact.id === artifactId);
+    if (!existing) {
+      throw new Error(`Artifact ${artifactId} not found`);
+    }
+    const versionEntry: ArtifactVersion = {
+      id: randomId(),
+      artifact: artifactId,
+      version,
+      createdAt: now(),
+      metadata,
+    };
+    const updated: ArtifactRecord = { ...existing, versions: [...existing.versions, versionEntry] };
+    return this.storage.upsertArtifact(updated);
+  }
+
+  listArtifacts(): ArtifactRecord[] {
+    return this.storage.listArtifacts();
+  }
+}
diff --git a/flowos/src/app/conversations/index.ts b/flowos/src/app/conversations/index.ts
new file mode 100644
index 0000000..9ae7f7f
--- /dev/null
+++ b/flowos/src/app/conversations/index.ts
@@ -0,0 +1,40 @@
+import { ConversationMessage, ConversationThread, FlowContext } from '../../types';
+import { MemoryStorage } from '../../storage';
+import { now, randomId } from '../../utils';
+
+export class ConversationManager {
+  constructor(private readonly storage: MemoryStorage) {}
+
+  startConversation(context: FlowContext): ConversationThread {
+    const thread: ConversationThread = {
+      id: randomId(),
+      messages: [],
+      persona: context.persona,
+      project: context.project,
+      createdAt: now(),
+    };
+    return this.storage.upsertConversation(thread);
+  }
+
+  appendMessage(threadId: string, author: ConversationMessage['author'], content: string, context: FlowContext): ConversationThread {
+    const thread = this.storage.getConversation(threadId);
+    if (!thread) {
+      throw new Error(`Conversation ${threadId} not found`);
+    }
+
+    const message: ConversationMessage = {
+      id: randomId(),
+      author,
+      content,
+      createdAt: now(),
+      context,
+    };
+
+    const updated: ConversationThread = { ...thread, messages: [...thread.messages, message] };
+    return this.storage.upsertConversation(updated);
+  }
+
+  list(): ConversationThread[] {
+    return this.storage.listConversations();
+  }
+}
diff --git a/flowos/src/app/memory/index.ts b/flowos/src/app/memory/index.ts
new file mode 100644
index 0000000..f6f5722
--- /dev/null
+++ b/flowos/src/app/memory/index.ts
@@ -0,0 +1,22 @@
+import { MemoryEntry } from '../../types';
+import { MemoryStorage } from '../../storage';
+import { now, randomId } from '../../utils';
+
+export class MemorySystem {
+  constructor(private readonly storage: MemoryStorage) {}
+
+  remember(scope: MemoryEntry['scope'], topic: string, payload: Record<string, unknown>): MemoryEntry {
+    const entry: MemoryEntry = {
+      id: randomId(),
+      scope,
+      topic,
+      payload,
+      createdAt: now(),
+    };
+    return this.storage.upsertMemory(entry);
+  }
+
+  recall(scope?: MemoryEntry['scope']): MemoryEntry[] {
+    return this.storage.listMemories(scope);
+  }
+}
diff --git a/flowos/src/app/projects/index.ts b/flowos/src/app/projects/index.ts
new file mode 100644
index 0000000..af75449
--- /dev/null
+++ b/flowos/src/app/projects/index.ts
@@ -0,0 +1,21 @@
+import { ProjectMetadata } from '../../types';
+import { MemoryStorage } from '../../storage';
+import { now, randomId } from '../../utils';
+
+export class ProjectRegistry {
+  constructor(private readonly storage: MemoryStorage) {}
+
+  registerProject(name: string, description?: string): ProjectMetadata {
+    const project: ProjectMetadata = {
+      id: randomId(),
+      name,
+      description,
+      createdAt: now(),
+    };
+    return this.storage.upsertProject(project);
+  }
+
+  listProjects(): ProjectMetadata[] {
+    return this.storage.listProjects();
+  }
+}
diff --git a/flowos/src/app/tools/index.ts b/flowos/src/app/tools/index.ts
new file mode 100644
index 0000000..7617ec5
--- /dev/null
+++ b/flowos/src/app/tools/index.ts
@@ -0,0 +1,24 @@
+import { ToolRegistration } from '../../types';
+import { randomId } from '../../utils';
+
+export class ToolRegistry {
+  private tools = new Map<string, ToolRegistration>();
+
+  registerTool(tool: Omit<ToolRegistration, 'id'> & { id?: string }): ToolRegistration {
+    const record: ToolRegistration = { ...tool, id: tool.id ?? randomId() };
+    this.tools.set(record.id, record);
+    return record;
+  }
+
+  invokeTool(id: string, payload: Record<string, unknown>): Promise<unknown> {
+    const tool = this.tools.get(id);
+    if (!tool) {
+      return Promise.reject(new Error(`Tool ${id} not found`));
+    }
+    return Promise.resolve(tool.handler(payload));
+  }
+
+  listTools(): ToolRegistration[] {
+    return [...this.tools.values()];
+  }
+}
diff --git a/flowos/src/core/chains/index.ts b/flowos/src/core/chains/index.ts
new file mode 100644
index 0000000..89e78fc
--- /dev/null
+++ b/flowos/src/core/chains/index.ts
@@ -0,0 +1,43 @@
+import crypto from 'crypto';
+import { FlowEvent, FlowContext, MerkleLink } from '../../types';
+import { hashPayload } from '../../utils';
+
+export class MerkleChain {
+  private links: MerkleLink[] = [];
+
+  append(event: FlowEvent, context: FlowContext): MerkleLink {
+    const parent = this.links.length ? this.links[this.links.length - 1].hash : undefined;
+    const payload = { event, context, parent };
+    const hash = crypto.createHash('sha256').update(JSON.stringify(payload)).digest('hex');
+    const link: MerkleLink = { hash, parent, context, event, createdAt: Date.now() };
+    this.links.push(link);
+    return link;
+  }
+
+  verify(): boolean {
+    for (let i = 0; i < this.links.length; i += 1) {
+      const link = this.links[i];
+      const expectedHash = crypto
+        .createHash('sha256')
+        .update(JSON.stringify({ event: link.event, context: link.context, parent: link.parent }))
+        .digest('hex');
+
+      if (expectedHash !== link.hash) {
+        return false;
+      }
+      if (i > 0 && this.links[i - 1].hash !== link.parent) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  trace(limit = 10): MerkleLink[] {
+    return this.links.slice(-limit);
+  }
+
+  digest(): string {
+    if (!this.links.length) return hashPayload({});
+    return this.links[this.links.length - 1].hash;
+  }
+}
diff --git a/flowos/src/core/particles/index.ts b/flowos/src/core/particles/index.ts
new file mode 100644
index 0000000..0138c62
--- /dev/null
+++ b/flowos/src/core/particles/index.ts
@@ -0,0 +1,26 @@
+import { FlowParticleSnapshot, FlowContext } from '../../types';
+import { ParticleStore } from './store';
+
+export class ParticleEngine {
+  constructor(private readonly store: ParticleStore) {}
+
+  createParticle(content: string, context: FlowContext, summary?: string): FlowParticleSnapshot {
+    return this.store.create(content, context, summary);
+  }
+
+  collapseParticle(id: string, by: string, note?: string): FlowParticleSnapshot {
+    return this.store.collapse(id, by, note);
+  }
+
+  archiveParticle(id: string, by: string, note?: string): FlowParticleSnapshot {
+    return this.store.archive(id, by, note);
+  }
+
+  getParticle(id: string): FlowParticleSnapshot | undefined {
+    return this.store.get(id);
+  }
+
+  listParticles(): FlowParticleSnapshot[] {
+    return this.store.list();
+  }
+}
diff --git a/flowos/src/core/particles/store.ts b/flowos/src/core/particles/store.ts
new file mode 100644
index 0000000..1307592
--- /dev/null
+++ b/flowos/src/core/particles/store.ts
@@ -0,0 +1,81 @@
+import { FlowParticleHistory, FlowParticleSnapshot, FlowParticleState, FlowContext } from '../../types';
+import { randomId, now } from '../../utils';
+
+export class ParticleStore {
+  private snapshots = new Map<string, FlowParticleSnapshot>();
+
+  create(content: string, context: FlowContext, summary?: string): FlowParticleSnapshot {
+    const state: FlowParticleState = {
+      id: randomId(),
+      status: 'draft',
+      content,
+      summary,
+      context,
+      createdAt: now(),
+      updatedAt: now(),
+    };
+
+    const snapshot: FlowParticleSnapshot = {
+      id: state.id,
+      history: [{ state, by: 'system', note: 'created' }],
+      latest: state,
+    };
+
+    this.snapshots.set(snapshot.id, snapshot);
+    return snapshot;
+  }
+
+  collapse(id: string, by: string, note?: string): FlowParticleSnapshot {
+    const current = this.snapshots.get(id);
+    if (!current) {
+      throw new Error(`Particle ${id} not found`);
+    }
+
+    const nextState: FlowParticleState = {
+      ...current.latest,
+      status: 'collapsed',
+      updatedAt: now(),
+    };
+
+    const historyEntry: FlowParticleHistory = { state: nextState, by, note };
+    const updated: FlowParticleSnapshot = {
+      ...current,
+      latest: nextState,
+      history: [...current.history, historyEntry],
+    };
+
+    this.snapshots.set(id, updated);
+    return updated;
+  }
+
+  archive(id: string, by: string, note?: string): FlowParticleSnapshot {
+    const current = this.snapshots.get(id);
+    if (!current) {
+      throw new Error(`Particle ${id} not found`);
+    }
+
+    const nextState: FlowParticleState = {
+      ...current.latest,
+      status: 'archived',
+      updatedAt: now(),
+    };
+
+    const historyEntry: FlowParticleHistory = { state: nextState, by, note };
+    const updated: FlowParticleSnapshot = {
+      ...current,
+      latest: nextState,
+      history: [...current.history, historyEntry],
+    };
+
+    this.snapshots.set(id, updated);
+    return updated;
+  }
+
+  get(id: string): FlowParticleSnapshot | undefined {
+    return this.snapshots.get(id);
+  }
+
+  list(): FlowParticleSnapshot[] {
+    return [...this.snapshots.values()];
+  }
+}
diff --git a/flowos/src/core/personas/index.ts b/flowos/src/core/personas/index.ts
new file mode 100644
index 0000000..c2a4390
--- /dev/null
+++ b/flowos/src/core/personas/index.ts
@@ -0,0 +1,31 @@
+import { PersonaRecord, PersonaProfile, PersonaTriangle } from '../../types';
+import { randomId } from '../../utils';
+
+export class PersonaRegistry {
+  private personas = new Map<string, PersonaRecord>();
+
+  registerPersona(profile: Omit<PersonaProfile, 'id'> & { id?: string }, triangle?: PersonaTriangle): PersonaRecord {
+    const persona: PersonaRecord = {
+      profile: { ...profile, id: profile.id ?? randomId() },
+      triangle,
+      seeds: [],
+    };
+    this.personas.set(persona.profile.id, persona);
+    return persona;
+  }
+
+  linkSeed(personaId: string, seedId: string): PersonaRecord {
+    const persona = this.personas.get(personaId);
+    if (!persona) {
+      throw new Error(`Persona ${personaId} not found`);
+    }
+    if (!persona.seeds.includes(seedId)) {
+      persona.seeds.push(seedId);
+    }
+    return persona;
+  }
+
+  listPersonas(): PersonaRecord[] {
+    return [...this.personas.values()];
+  }
+}
diff --git a/flowos/src/core/seeds/index.ts b/flowos/src/core/seeds/index.ts
new file mode 100644
index 0000000..56e84e7
--- /dev/null
+++ b/flowos/src/core/seeds/index.ts
@@ -0,0 +1,31 @@
+import { SeedDefinition, SeedMigration } from '../../types';
+import { now, randomId } from '../../utils';
+
+export class SeedRegistry {
+  private seeds = new Map<string, SeedDefinition>();
+
+  registerSeed(seed: Omit<SeedDefinition, 'id' | 'migrations'> & { migrations?: SeedMigration[]; id?: string }): SeedDefinition {
+    const definition: SeedDefinition = {
+      ...seed,
+      id: seed.id ?? randomId(),
+      migrations: seed.migrations ?? [],
+    };
+    this.seeds.set(definition.id, definition);
+    return definition;
+  }
+
+  addMigration(seedId: string, migration: Omit<SeedMigration, 'id' | 'createdAt'>): SeedDefinition {
+    const seed = this.seeds.get(seedId);
+    if (!seed) {
+      throw new Error(`Seed ${seedId} not found`);
+    }
+
+    const record: SeedMigration = { ...migration, id: randomId(), createdAt: now() };
+    seed.migrations.push(record);
+    return seed;
+  }
+
+  listSeeds(): SeedDefinition[] {
+    return [...this.seeds.values()];
+  }
+}
diff --git a/flowos/src/index.ts b/flowos/src/index.ts
new file mode 100644
index 0000000..64639e5
--- /dev/null
+++ b/flowos/src/index.ts
@@ -0,0 +1,73 @@
+import { FlowContext, FlowEvent, FlowSnapshot } from './types';
+import { MemoryStorage } from './storage';
+import { ParticleEngine } from './core/particles';
+import { ParticleStore } from './core/particles/store';
+import { MerkleChain } from './core/chains';
+import { SeedRegistry } from './core/seeds';
+import { PersonaRegistry } from './core/personas';
+import { FlowLaw } from './lib/flow-law';
+import { ConversationManager } from './app/conversations';
+import { ProjectRegistry } from './app/projects';
+import { ArtifactVault } from './app/artifacts';
+import { MemorySystem } from './app/memory';
+import { ToolRegistry } from './app/tools';
+import { randomId, now } from './utils';
+
+export class FlowOS {
+  readonly storage: MemoryStorage;
+  readonly particles: ParticleEngine;
+  readonly particleStore: ParticleStore;
+  readonly chain: MerkleChain;
+  readonly seeds: SeedRegistry;
+  readonly personas: PersonaRegistry;
+  readonly flowLaw: FlowLaw;
+  readonly conversations: ConversationManager;
+  readonly projects: ProjectRegistry;
+  readonly artifacts: ArtifactVault;
+  readonly memory: MemorySystem;
+  readonly tools: ToolRegistry;
+
+  constructor() {
+    this.storage = new MemoryStorage();
+    this.particleStore = new ParticleStore();
+    this.particles = new ParticleEngine(this.particleStore);
+    this.chain = new MerkleChain();
+    this.seeds = new SeedRegistry();
+    this.personas = new PersonaRegistry();
+    this.flowLaw = new FlowLaw();
+    this.conversations = new ConversationManager(this.storage);
+    this.projects = new ProjectRegistry(this.storage);
+    this.artifacts = new ArtifactVault(this.storage);
+    this.memory = new MemorySystem(this.storage);
+    this.tools = new ToolRegistry();
+  }
+
+  createContext(partial: Partial<FlowContext> = {}): FlowContext {
+    return {
+      id: partial.id ?? randomId(),
+      createdAt: partial.createdAt ?? now(),
+      ...partial,
+    };
+  }
+
+  dispatch(eventType: string, payload: Record<string, unknown>, context: FlowContext): FlowEvent {
+    const event: FlowEvent = { id: randomId(), type: eventType, payload, createdAt: now() };
+    this.chain.append(event, context);
+    return event;
+  }
+
+  enforce(context?: FlowContext) {
+    return this.flowLaw.evaluate(this.particles.listParticles(), context);
+  }
+
+  snapshot(): FlowSnapshot {
+    const snapshot = this.storage.snapshot();
+    return {
+      ...snapshot,
+      particles: this.particles.listParticles(),
+    };
+  }
+}
+
+export * from './types';
+export * from './utils';
diff --git a/flowos/src/lib/flow-law.ts b/flowos/src/lib/flow-law.ts
new file mode 100644
index 0000000..c667726
--- /dev/null
+++ b/flowos/src/lib/flow-law.ts
@@ -0,0 +1,27 @@
+import { FlowContext, FlowLawResult, FlowLawViolation, FlowParticleSnapshot } from '../types';
+
+export class FlowLaw {
+  evaluate(particles: FlowParticleSnapshot[], context?: FlowContext): FlowLawResult {
+    const violations: FlowLawViolation[] = [];
+
+    const uncollapsed = particles.filter((particle) => particle.latest.status === 'draft');
+    if (uncollapsed.length > 10) {
+      violations.push({
+        code: 'PARTICLE_OVERFLOW',
+        message: 'Too many draft particles without collapse',
+        context,
+      });
+    }
+
+    const orphaned = particles.filter((particle) => !particle.latest.context.persona);
+    if (orphaned.length) {
+      violations.push({
+        code: 'ORPHANED_PARTICLE',
+        message: 'Particles should reference a persona to maintain narrative consistency',
+        context,
+      });
+    }
+
+    return { passed: violations.length === 0, violations };
+  }
+}
diff --git a/flowos/src/storage/index.ts b/flowos/src/storage/index.ts
new file mode 100644
index 0000000..b3f256d
--- /dev/null
+++ b/flowos/src/storage/index.ts
@@ -0,0 +1,101 @@
+import { FlowSnapshot, MemoryEntry, PersonaRecord, SeedDefinition, FlowParticleSnapshot, ConversationThread, ProjectMetadata, ArtifactRecord } from '../types';
+import { randomId, now } from '../utils';
+
+type Collection<T> = Map<string, T>;
+
+export class MemoryStorage {
+  private particles: Collection<FlowParticleSnapshot> = new Map();
+  private personas: Collection<PersonaRecord> = new Map();
+  private seeds: Collection<SeedDefinition> = new Map();
+  private conversations: Collection<ConversationThread> = new Map();
+  private projects: Collection<ProjectMetadata> = new Map();
+  private artifacts: Collection<ArtifactRecord> = new Map();
+  private memories: Collection<MemoryEntry> = new Map();
+
+  upsertParticle(snapshot: FlowParticleSnapshot): FlowParticleSnapshot {
+    const persisted = { ...snapshot, latest: { ...snapshot.latest, updatedAt: now() } };
+    this.particles.set(snapshot.id, persisted);
+    return persisted;
+  }
+
+  getParticle(id: string): FlowParticleSnapshot | undefined {
+    return this.particles.get(id);
+  }
+
+  listParticles(): FlowParticleSnapshot[] {
+    return [...this.particles.values()];
+  }
+
+  upsertPersona(record: PersonaRecord): PersonaRecord {
+    this.personas.set(record.profile.id, record);
+    return record;
+  }
+
+  listPersonas(): PersonaRecord[] {
+    return [...this.personas.values()];
+  }
+
+  upsertSeed(seed: SeedDefinition): SeedDefinition {
+    this.seeds.set(seed.id, seed);
+    return seed;
+  }
+
+  listSeeds(): SeedDefinition[] {
+    return [...this.seeds.values()];
+  }
+
+  upsertConversation(thread: ConversationThread): ConversationThread {
+    this.conversations.set(thread.id, thread);
+    return thread;
+  }
+
+  getConversation(id: string): ConversationThread | undefined {
+    return this.conversations.get(id);
+  }
+
+  listConversations(): ConversationThread[] {
+    return [...this.conversations.values()];
+  }
+
+  upsertProject(project: ProjectMetadata): ProjectMetadata {
+    this.projects.set(project.id, project);
+    return project;
+  }
+
+  listProjects(): ProjectMetadata[] {
+    return [...this.projects.values()];
+  }
+
+  upsertArtifact(record: ArtifactRecord): ArtifactRecord {
+    this.artifacts.set(record.id, record);
+    return record;
+  }
+
+  listArtifacts(): ArtifactRecord[] {
+    return [...this.artifacts.values()];
+  }
+
+  upsertMemory(memory: MemoryEntry): MemoryEntry {
+    const item = memory.id ? memory : { ...memory, id: randomId(), createdAt: now() };
+    this.memories.set(item.id, item);
+    return item;
+  }
+
+  listMemories(scope?: MemoryEntry['scope']): MemoryEntry[] {
+    const entries = [...this.memories.values()];
+    if (!scope) return entries;
+    return entries.filter((entry) => entry.scope === scope);
+  }
+
+  snapshot(): FlowSnapshot {
+    return {
+      particles: this.listParticles(),
+      personas: this.listPersonas(),
+      seeds: this.listSeeds(),
+      conversations: this.listConversations(),
+      projects: this.listProjects(),
+      artifacts: this.listArtifacts(),
+      memories: this.listMemories(),
+    };
+  }
+}
diff --git a/flowos/src/types/index.ts b/flowos/src/types/index.ts
new file mode 100644
index 0000000..fe32425
--- /dev/null
+++ b/flowos/src/types/index.ts
@@ -0,0 +1,163 @@
+export type UUID = string;
+
+export interface FlowContext {
+  id: UUID;
+  project?: string;
+  persona?: UUID;
+  seed?: UUID;
+  createdAt: number;
+  metadata?: Record<string, unknown>;
+}
+
+export interface FlowEvent {
+  id: UUID;
+  type: string;
+  payload: Record<string, unknown>;
+  createdAt: number;
+}
+
+export interface FlowParticleState {
+  id: UUID;
+  status: 'draft' | 'collapsed' | 'archived';
+  content: string;
+  summary?: string;
+  context: FlowContext;
+  createdAt: number;
+  updatedAt: number;
+}
+
+export interface FlowParticleHistory {
+  state: FlowParticleState;
+  by: string;
+  note?: string;
+}
+
+export interface FlowParticleSnapshot {
+  id: UUID;
+  history: FlowParticleHistory[];
+  latest: FlowParticleState;
+}
+
+export interface MerkleLink {
+  hash: string;
+  parent?: string;
+  context: FlowContext;
+  event: FlowEvent;
+  createdAt: number;
+}
+
+export interface PersonaProfile {
+  id: UUID;
+  name: string;
+  description?: string;
+  tone?: string;
+  traits?: string[];
+}
+
+export interface PersonaTriangle {
+  primary: string;
+  secondary?: string;
+  adversarial?: string;
+}
+
+export interface PersonaRecord {
+  profile: PersonaProfile;
+  triangle?: PersonaTriangle;
+  seeds: UUID[];
+}
+
+export interface SeedMigration {
+  id: UUID;
+  from: string;
+  to: string;
+  summary: string;
+  createdAt: number;
+}
+
+export interface SeedDefinition {
+  id: UUID;
+  name: string;
+  version: string;
+  description?: string;
+  migrations: SeedMigration[];
+  payload: Record<string, unknown>;
+}
+
+export interface ConversationMessage {
+  id: UUID;
+  author: 'user' | 'assistant' | 'system';
+  content: string;
+  createdAt: number;
+  context: FlowContext;
+}
+
+export interface ConversationThread {
+  id: UUID;
+  messages: ConversationMessage[];
+  persona?: UUID;
+  project?: UUID;
+  createdAt: number;
+}
+
+export interface ProjectMetadata {
+  id: UUID;
+  name: string;
+  description?: string;
+  repository?: string;
+  knowledgeBase?: string[];
+  createdAt: number;
+}
+
+export interface ArtifactVersion {
+  id: UUID;
+  artifact: UUID;
+  version: string;
+  createdAt: number;
+  metadata?: Record<string, unknown>;
+}
+
+export interface ArtifactRecord {
+  id: UUID;
+  project: UUID;
+  name: string;
+  description?: string;
+  versions: ArtifactVersion[];
+}
+
+export interface MemoryEntry {
+  id: UUID;
+  scope: 'conversation' | 'project' | 'global';
+  topic: string;
+  embedding?: number[];
+  payload: Record<string, unknown>;
+  createdAt: number;
+}
+
+export interface ToolRegistration {
+  id: UUID;
+  name: string;
+  description?: string;
+  handler: (payload: Record<string, unknown>) => Promise<unknown> | unknown;
+  metadata?: Record<string, unknown>;
+}
+
+export interface FlowSnapshot {
+  particles: FlowParticleSnapshot[];
+  personas: PersonaRecord[];
+  seeds: SeedDefinition[];
+  conversations: ConversationThread[];
+  projects: ProjectMetadata[];
+  artifacts: ArtifactRecord[];
+  memories: MemoryEntry[];
+}
+
+export interface FlowLawViolation {
+  code: string;
+  message: string;
+  context?: FlowContext;
+}
+
+export interface FlowLawResult {
+  passed: boolean;
+  violations: FlowLawViolation[];
+}
diff --git a/flowos/src/utils/index.ts b/flowos/src/utils/index.ts
new file mode 100644
index 0000000..6991549
--- /dev/null
+++ b/flowos/src/utils/index.ts
@@ -0,0 +1,32 @@
+import crypto from 'crypto';
+import { UUID } from '../types';
+
+export const now = (): number => Date.now();
+
+export const randomId = (): UUID => crypto.randomUUID();
+
+export function chunkText(text: string, size: number): string[] {
+  if (size <= 0) return [text];
+  const normalized = text.trim();
+  const result: string[] = [];
+  for (let i = 0; i < normalized.length; i += size) {
+    result.push(normalized.slice(i, i + size));
+  }
+  return result;
+}
+
+export function shallowMerge<T extends object, U extends object>(base: T, incoming: U): T & U {
+  return { ...base, ...incoming } as T & U;
+}
+
+export function ensure<T>(value: T | undefined | null, message: string): T {
+  if (value === undefined || value === null) {
+    throw new Error(message);
+  }
+  return value;
+}
+
+export function hashPayload(payload: unknown): string {
+  const buffer = Buffer.from(JSON.stringify(payload));
+  return crypto.createHash('sha256').update(buffer).digest('hex');
+}
diff --git a/flowos/test.ts b/flowos/test.ts
new file mode 100644
index 0000000..b05dda1
--- /dev/null
+++ b/flowos/test.ts
@@ -0,0 +1,20 @@
+import { FlowOS } from './src';
+
+const flow = new FlowOS();
+const context = flow.createContext({ persona: 'demo-persona' });
+
+const particle = flow.particles.createParticle('Hello FlowOS', context, 'intro message');
+flow.particles.collapseParticle(particle.id, 'demo');
+
+const conversation = flow.conversations.startConversation(context);
+flow.conversations.appendMessage(conversation.id, 'user', 'Hello there', context);
+
+const project = flow.projects.registerProject('FlowOS Sandbox', 'Playground for FlowOS runtime');
+const artifact = flow.artifacts.registerArtifact(project.id, 'Transcript');
+flow.artifacts.addVersion(artifact.id, 'v1');
+
+flow.memory.remember('project', 'first-run', { project: project.name, conversation: conversation.id });
+
+console.log('Flow snapshot:', JSON.stringify(flow.snapshot(), null, 2));
+console.log('Chain digest:', flow.chain.digest());
+console.log('FlowLaw:', flow.enforce());
diff --git a/flowos/tsconfig.json b/flowos/tsconfig.json
new file mode 100644
index 0000000..8293ca0
--- /dev/null
+++ b/flowos/tsconfig.json
@@ -0,0 +1,16 @@
+{
+  "compilerOptions": {
+    "target": "ES2020",
+    "module": "CommonJS",
+    "moduleResolution": "Node",
+    "rootDir": "./",
+    "outDir": "./dist",
+    "strict": true,
+    "esModuleInterop": true,
+    "forceConsistentCasingInFileNames": true,
+    "skipLibCheck": true,
+    "resolveJsonModule": true,
+    "types": ["node"]
+  },
+  "include": ["src/**/*", "test.ts"]
+}
diff --git a/package-lock.json b/package-lock.json
index b77ad06..0cf3538 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -15,6 +15,10 @@
         "next": "14.2.35",
         "react": "18.3.1",
         "react-dom": "18.3.1"
+      },
+      "devDependencies": {
+        "@types/node": "^25.0.3",
+        "typescript": "^5.9.3"
       }
     },
     "node_modules/@edge-runtime/cookies": {
@@ -215,6 +219,16 @@
         "tslib": "^2.4.0"
       }
     },
+    "node_modules/@types/node": {
+      "version": "25.0.3",
+      "resolved": "https://registry.npmjs.org/@types/node/-/node-25.0.3.tgz",
+      "integrity": "sha512-W609buLVRVmeW693xKfzHeIV6nJGGz98uCPfeXI1ELMLXVeKYZ9m15fAMSaUPBHYLGFsVRcMmSCksQOrZV9BYA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "undici-types": "~7.16.0"
+      }
+    },
     "node_modules/@vercel/edge-config": {
       "version": "1.4.3",
       "resolved": "https://registry.npmjs.org/@vercel/edge-config/-/edge-config-1.4.3.tgz",
@@ -574,6 +588,27 @@
       "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
       "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
       "license": "0BSD"
+    },
+    "node_modules/typescript": {
+      "version": "5.9.3",
+      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.9.3.tgz",
+      "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "bin": {
+        "tsc": "bin/tsc",
+        "tsserver": "bin/tsserver"
+      },
+      "engines": {
+        "node": ">=14.17"
+      }
+    },
+    "node_modules/undici-types": {
+      "version": "7.16.0",
+      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-7.16.0.tgz",
+      "integrity": "sha512-Zz+aZWSj8LE6zoxD+xrjh4VfkIG8Ya6LvYkZqtUQGJPZjYl53ypCaUwWqo7eI0x66KBGeRo+mlBEkMSeSZ38Nw==",
+      "dev": true,
+      "license": "MIT"
     }
   }
 }
diff --git a/package.json b/package.json
index 5128795..680f416 100644
--- a/package.json
+++ b/package.json
@@ -9,12 +9,16 @@
     "lint": "next lint"
   },
   "dependencies": {
-    "next": "14.2.35",
-    "react": "18.3.1",
-    "react-dom": "18.3.1",
     "@flags-sdk/growthbook": "0.2.0",
     "@growthbook/growthbook": "1.5.1",
     "flags": "^4.0.0",
-    "nanoid": "5.1.2"
+    "nanoid": "5.1.2",
+    "next": "14.2.35",
+    "react": "18.3.1",
+    "react-dom": "18.3.1"
+  },
+  "devDependencies": {
+    "@types/node": "^25.0.3",
+    "typescript": "^5.9.3"
   }
 }
